from tqdm import tqdm
from rdkit import RDLogger

# Disable the RDKit logger
RDLogger.DisableLog('rdApp.error')

from PIL import Image
import numpy as np
from rdkit import Chem
from rdkit.Chem.Draw import rdDepictor, rdMolDraw2D
from PIL import Image
from io import BytesIO
import glob,os,sys,math,json
from preprocessing.database import *

sys.path.insert(0, os.path.abspath('..'))
from Constants import ui_constants,ml_constants,preprop_constants,file_constants
from ui.terminal_ui import *
from utilities import file_utils,img_utils,utils




class TargetGenerator:
    def __init__(self,database):
        '''
        Scaler class for normalizing scale and proportions of molecular skeletons generated by RDKit for use as target molcules

        Parameters
        ----------
        data_folder : str
            The path to the data folder

        database : Database
            The database object containing the smiles
        '''
        self.database = database
        
        self.smiles = self.database.get_smiles()

    def generate_skeletons(self,count):
        '''
        Preprocesses the smiles into preprocessed images
        
        -> Load the smiles from the database if requested
        -> Normalise the molecules so bonds and atoms are the same length
        -> Get the maximum dimensions of the normalised smiles
            -> Calculate the average dimensions of the smiles
            -> Work out an upper bound for the dimensions so most of smiles will fit into the images. This accounts for outliers.
            -> Calculate the scale factor
        -> Scale the smiles to the same size
        -> Convert the smiles to black and white
        -> Save the smiles to the folder

        '''
        if count == None:
            count = len(self.smiles)
        else:
            count = min(count,len(self.smiles))
        
        # --- Redownload the images if Requested ---
        print(format_title("Downloading Skeletons"))
        file_utils.clear_folder(file_constants.PROCESSED_DATA)
        self.create_skeletons(count)

    def normalise_targets(self):
        '''
        Normalise the target images to standardise structural proportions and fit into target dimensions
        '''

        # --- Scale the images ---
        print(format_title("Scaling Images"))
        self.sizes = np.sort(self.get_skeleton_sizes())
        upper_bound = utils.get_percentile_upper_bound(self.sizes,percentile=preprop_constants.BOUND_PERCENTILE) # Get Upper Bound from Percentile
        #upper_bound = self.get_distribution_upper_bounds(sizes,STD_DEV)
        upper_bound = min(upper_bound,800) # Change this to a constant
        scale_factor = preprop_constants.IMG_SIZE / upper_bound

        # Rescale the images with new scale factor


        self.rescale_skeletons(scale_factor,upper_bound)
        # --- Additional Processing ---
        #self.recolour() - Leave this for now
        

    def truncate_smile(self,smile):
        '''
        Truncate the smile to  fit into file name length limit

        Windows 11 has a file length limit of 255 characters

        Issue with this as it doesnt allow for matching of drugs
        '''
        if len(smile) > preprop_constants.MAX_CHARS:
            return smile[:preprop_constants.MAX_CHARS]
        else:
            return smile
    
    
    
    def save_dataset_info(self):
        '''
        Saves dataset information to a json file

        Information Saved:
            -> Dataset Name
            -> Dataset Size
            -> Dataset Target Image Size
            -> Dataset Standard Deviation
            -> Dataset Unscaled Sizes
        '''
         # --- Visualise the dataset ---
        #utils.plot_distribution(self.sizes,"Skeleton Sizes","Frequency")

        dataset_info = {
            "dataset_SIZE": len(self.smiles),
            "dataset_TARGET_IMG_SIZE": preprop_constants.IMG_SIZE,
            "dataset_STD_DEV": preprop_constants.STD_DEV,
            "dataset_UNSCALED_SIZES": self.sizes.tolist()
        }
        with open(fr'{file_constants.PROCESSED_DATA}\dataset_info.json', 'w') as outfile:
            json.dump(dataset_info, outfile)

    def create_skeletons(self,count):
        '''
        Creates the skeleton images from smiles
        '''
        for (i,smile) in tqdm(enumerate(self.smiles),total=len(self.smiles), bar_format=ui_constants.LOADING_BAR, ncols=80, colour='green'):
            try:
                # Create the skeleton image
                mol = Chem.MolFromSmiles(smile)
                # Calculate the 2D coordinates of the molecule
                #Chem.Kekulize(mol) # Ensure the molecule is kekulized, Do I need to do this?
                rdDepictor.Compute2DCoords(mol)
                # Scale the skeleton image
                img = self.scale_skeleton(mol)
                # Truncate the smile to fit into file name length limit
                name = self.database.get_id(smile)
                img.save(fr'{file_constants.PROCESSED_DATA}\{name}.png')
                count -= 1
                if count <= 0:
                    break

            except Exception as e:
                pass

    def scale_skeleton(self,mol):
        '''
        Normalises the molecule so bonds and atoms are the same length
        '''
    
        # Molecule cordinates are normalised so bonds and atoms are the same length
        rdDepictor.NormalizeDepiction(mol)

        # -1, -1 flexicanvas: the canvas will be as large as needed to display the molecule (no scaling)
        drawer = rdMolDraw2D.MolDraw2DCairo(-1, -1)
        opts = rdMolDraw2D.MolDrawOptions()
        drawer.SetDrawOptions(opts)
        drawer.DrawMolecule(mol) 
        drawer.FinishDrawing()

        with BytesIO(drawer.GetDrawingText()) as hnd:
            with Image.open(hnd) as image:
                image.load()

        return image
    
    def get_skeleton_sizes(self):
        '''
        Iterates through every image in the folder and returns a list of the skeleton sizes
        '''
        

        img_sizes = []
        for image in os.listdir(file_constants.PROCESSED_DATA):
            if image.endswith(".png"):
                with Image.open(os.path.join(file_constants.PROCESSED_DATA, image)) as img:
                    img_sizes.append(img.width)
                    img_sizes.append(img.height)
        return img_sizes

    
    
    def rescale_skeletons(self,scale_factor,scale_size):
        '''
        Rescales the skeleton images to the target image size without distorting the image

        This function standardises the data for the model

        If one of the dimensions of an image is greater than the target scale factor it is rotated 45 degrees
        '''
        image_files = file_utils.get_files(file_constants.PROCESSED_DATA,"png")
        rotated = 0
        for (i, skeleton) in tqdm(enumerate(image_files), total=len(image_files), bar_format=ui_constants.LOADING_BAR, ncols=80, colour='green'):
            smile = os.path.splitext(os.path.basename(skeleton))[0]
            rotation = None
            
            # Process each image file
            with Image.open(skeleton) as img:
                # Calculates what the new dimensions would be with scaling
                if img.width > scale_size or img.height > scale_size:
                    #rotation = self.calculate_best_rotation(img.width,img.height,scale_factor) - Works but not really necessary
                    rotated += 1
                    rotation = 45
                
                if rotation is not None:
                    img = img.rotate(rotation, expand=True, fillcolor='white')
            
                new_width = int(img.width * scale_factor)
                new_height = int(img.height * scale_factor)
                
                # Resize the image to the new dimensions
                img = img.resize((new_width, new_height))
                
                # Create a blank white background
                background = Image.new('RGB', (preprop_constants.IMG_SIZE, preprop_constants.IMG_SIZE), (255, 255, 255))
                
                # Paste the molecule image onto the center of the background
                offset = tuple((bg_dim - img_dim) // 2 for bg_dim, img_dim in zip(background.size, img.size))
                
                background.paste(img, offset)
                

            background.save(fr'{file_constants.PROCESSED_DATA}\{smile}.png')

        print(format_title("Preprocessing Summary"))
        strings = ["Generated From Smiles","Bound Used","Amount of Images Above bound"]
        outputs = [f"{(len(image_files)*100/len(self.smiles))}%",scale_size,f"{rotated}/{len(image_files)}"]
        print(console_grid(strings,outputs))